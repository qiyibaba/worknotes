```
2022-10-17 10:28:37 OB咨询问题
问题一：咨询有关SSN数据物理序号
通讯发送程序AS400实现逻辑当前现状：
1）1~10亿级以内的表；
2）多个线程按照物理序进行区间分发处理；

OB替代方案：
1）继续沿用AS400的这套物理序机制，使用OceanBase的物理序进行处理，需确认OB物理序与AS400物理序的区别。
2）推荐实现新的一套分区机制，不依赖物理序，需重点关注性能。

问题二：两张表中大数据比对问题
需求描述：
1）两张表，数据量都是1~10亿级别
2）比对这两张表数据是否完全一致，不一致显示差异记录。
```

问题1:

OceanBase自增列的使用方式

1. OceanBase使用的是类似mysql自增列的实现方式，所以需要添加一个新字段，该字段可以不用赋值

2. OceanBase自增列可能在故障的时候存在数据的跳变（默认跳变1000000），但是能够保证自增列的连续

3. 使用方式如下：

   ```
   附：OCEANBASE使用自增长字段测试情况(表中测试数据1亿)
   create table xtfststpf(id bigint not null auto_increment, cfbz char(10) not null , tstfld1 char(256) not null,tstfld2 char(256) not null,primary key(cfbz,id)) partition by key(cfbz) partitions 13;
   -- 创建数据表，主键(自增字段+拆分标志），分区键(拆分标志)，分区13个。 
   
   拆分语句：
   select * from xtfststpf where cfbz='BCD';
   该语句等同于：
   select * from xtfststpf where cfbz='BCD' order by id;
   ```

问题2：

OceanBase  MySQL 模式下的自增列，设计行为尽可能和 MySQL 兼容，对用途提供了如下特性：
● 向自增列主动插入一个值 i 后，后继这张表上自动生成的值都需要比 i 大
● 每个分区上自动生成的值，总是单调递增的

自增列在用的过程中会观测到“跳”，触发跳的场景包括：
● 两次访问的不是同一个分区
● 切主
● 合并
● 主动 insert 一个大自增值
● insert on duplicate update



问题2：

使用except函数，使用方式示例如下：

```
MySQL [ny]> create table t2 (id int,col varchar(10));
Query OK, 0 rows affected (0.05 sec)

MySQL [ny]> create table t1 (id int,col varchar(10));
Query OK, 0 rows affected (0.05 sec)

MySQL [ny]> insert into t1 values (1,'a'),(2,'b'),(3,'a');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

MySQL [ny]> insert into t2 values (4,'a'),(2,'b'),(3,'c');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

MySQL [ny]> (select * from t1 except select * from t2) union all (select * from t2 except select * from t1);
+------+------+
| id   | col  |
+------+------+
|    1 | a    |
|    3 | a    |
|    4 | a    |
|    3 | c    |
+------+------+
4 rows in set (0.01 sec)
```

注意事项：

1. 数据量超千万不能直接使用except进行全表比较，可以使用范围字段进行拆分，如：

   ```
   MySQL [ny]> (select * from user1 where id between 0 and 100000 except select * from user2 where id between 0 and 100000) union all (select * from user2 where id between 0 and 100000 except select * from user1 where id between 0 and 100000);
   Empty set (1.03 sec)
   ```

2. 测试数据如下，10w条数据比较约1s

3. 可以使用并发进行校验提升性能